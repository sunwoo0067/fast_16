---
alwaysApply: false
description: "ë“œëì‹­í•‘ ìë™í™” ì‹œìŠ¤í…œì˜ ì½”ë”© ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¼ì¸"
globs: "src/**/*.py,frontend/src/**/*.{ts,tsx}"
---

# ì½”ë”© ìŠ¤íƒ€ì¼ ê°€ì´ë“œë¼ì¸

ë“œëì‹­í•‘ ìë™í™” ì‹œìŠ¤í…œì˜ ì¼ê´€ëœ ì½”ë“œ í’ˆì§ˆì„ ìœ ì§€í•˜ê¸° ìœ„í•œ ê°€ì´ë“œë¼ì¸ì…ë‹ˆë‹¤.

## ğŸ Python ì½”ë”© ìŠ¤íƒ€ì¼

### 1. ê¸°ë³¸ ê·œì¹™
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ
from typing import List, Optional, Dict, Any
from datetime import datetime

class ExampleClass:
    """í´ë˜ìŠ¤ ì„¤ëª…ì€ ë…ìŠ¤íŠ¸ë§ìœ¼ë¡œ ì‘ì„±"""

    def __init__(self, param1: str, param2: Optional[int] = None) -> None:
        """ìƒì„±ì ì„¤ëª…"""
        self.param1 = param1
        self.param2 = param2

    async def process_data(self, data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """ë°ì´í„° ì²˜ë¦¬ ë©”ì„œë“œ"""
        result = {}

        for item in data:
            # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
            processed = await self._process_item(item)
            result[item['id']] = processed

        return result

    async def _process_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        """ê°œë³„ ì•„ì´í…œ ì²˜ë¦¬ (private ë©”ì„œë“œ)"""
        return {
            'id': item['id'],
            'processed': True,
            'timestamp': datetime.now().isoformat()
        }

# âŒ ë‚˜ìœ ì˜ˆì‹œ
# import *
# class bad:
#     def bad_method(self, x): pass
#     async def process(self): pass
```

### 2. ë³€ìˆ˜ ë° í•¨ìˆ˜ ëª…ëª…
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ
class ProductService:
    def __init__(self, repository: ProductRepository) -> None:
        self.repository = repository
        self.max_retry_count = 3
        self.timeout_seconds = 30

    async def get_product_by_id(self, product_id: str) -> Optional[Product]:
        """ìƒí’ˆ IDë¡œ ì¡°íšŒ"""
        return await self.repository.find_by_id(product_id)

    async def sync_product_data(self, supplier_id: str) -> Result[List[Product], str]:
        """ìƒí’ˆ ë°ì´í„° ë™ê¸°í™”"""
        return await self._sync_from_supplier(supplier_id)

# âŒ ë‚˜ìœ ì˜ˆì‹œ
class ps:
    def __init__(self, r):
        self.r = r
        self.mrc = 3
        self.ts = 30

    def gpbi(self, pid):
        return self.r.fbi(pid)

    def spd(self, sid):
        return self._sfs(sid)
```

### 3. ì—ëŸ¬ ì²˜ë¦¬
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ
from src.shared.result import Result, Success, Failure

async def safe_operation() -> Result[Data, str]:
    try:
        # ìœ„í—˜í•œ ì‘ì—…
        result = await risky_api_call()
        return Success(result)
    except ValueError as e:
        return Failure(f"ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: {str(e)}")
    except ConnectionError as e:
        return Failure(f"ì—°ê²° ì‹¤íŒ¨: {str(e)}")
    except Exception as e:
        logger.error(f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {e}", exc_info=True)
        return Failure("ì‹œìŠ¤í…œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤")

# âŒ ë‚˜ìœ ì˜ˆì‹œ
async def unsafe_operation():
    try:
        result = await risky_api_call()
        return result
    except:
        return None  # ì—ëŸ¬ ì •ë³´ ìœ ì‹¤
```

### 4. ë¹„ë™ê¸°/ë™ê¸° í•¨ìˆ˜ ì‚¬ìš©
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ
class DataProcessor:
    async def process_batch(self, items: List[Item]) -> List[ProcessedItem]:
        """ë°°ì¹˜ ì²˜ë¦¬ (CPU ì§‘ì•½ì  ì‘ì—…)"""
        semaphore = asyncio.Semaphore(10)  # ë™ì‹œì„± ì œì–´

        async def process_single(item: Item) -> ProcessedItem:
            async with semaphore:
                return await self._heavy_computation(item)

        # ë³‘ë ¬ ì²˜ë¦¬
        tasks = [process_single(item) for item in items]
        return await asyncio.gather(*tasks)

    async def _heavy_computation(self, item: Item) -> ProcessedItem:
        """ë¬´ê±°ìš´ ê³„ì‚° ì‘ì—…"""
        await asyncio.sleep(0.1)  # I/O ì‹œë®¬ë ˆì´ì…˜
        return ProcessedItem(id=item.id, processed=True)

# âŒ ë‚˜ìœ ì˜ˆì‹œ
async def bad_process():
    for item in items:
        # ë™ê¸° í•¨ìˆ˜ë¥¼ asyncì—ì„œ ì§ì ‘ í˜¸ì¶œ (ë¸”ë¡í‚¹)
        result = sync_function(item)  # âŒ ì´ë²¤íŠ¸ ë£¨í”„ ë¸”ë¡í‚¹
        results.append(result)
```

### 5. ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ
from sqlalchemy import select, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession

class ProductRepository:
    async def find_by_supplier_and_category(
        self,
        db: AsyncSession,
        supplier_id: str,
        category_id: str
    ) -> List[Product]:
        """ê³µê¸‰ì‚¬ì™€ ì¹´í…Œê³ ë¦¬ë¡œ ìƒí’ˆ ì¡°íšŒ"""
        stmt = select(Product).where(
            and_(
                Product.supplier_id == supplier_id,
                Product.category_id == category_id,
                Product.is_active == True
            )
        ).order_by(Product.created_at.desc())

        result = await db.execute(stmt)
        return result.scalars().all()

# âŒ ë‚˜ìœ ì˜ˆì‹œ
async def bad_query(db):
    # ë¬¸ìì—´ë¡œ ì§ì ‘ ì¿¼ë¦¬ (SQL ì¸ì ì…˜ ìœ„í—˜)
    query = f"SELECT * FROM products WHERE supplier_id = '{supplier_id}'"
    return await db.execute(query)
```

## âš›ï¸ TypeScript/React ì½”ë”© ìŠ¤íƒ€ì¼

### 1. ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°
```typescript
// âœ… ì¢‹ì€ ì˜ˆì‹œ
import React, { useState, useEffect, useCallback } from 'react';
import { Card, Button, Table, Modal, Form } from 'antd';
import { useProductsStore } from '@/stores/products';

interface ProductListProps {
  onEdit?: (product: Product) => void;
  onDelete?: (productId: string) => void;
}

const ProductList: React.FC<ProductListProps> = ({ onEdit, onDelete }) => {
  const { products, loading, error, fetchProducts, deleteProduct } = useProductsStore();

  const [selectedRowKeys, setSelectedRowKeys] = useState<React.Key[]>([]);
  const [deleteModalVisible, setDeleteModalVisible] = useState(false);

  const handleDelete = useCallback(async () => {
    try {
      await deleteProduct(selectedRowKeys[0] as string);
      setDeleteModalVisible(false);
      message.success('ìƒí’ˆì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
    } catch (error) {
      message.error('ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    }
  }, [selectedRowKeys, deleteProduct]);

  useEffect(() => {
    fetchProducts();
  }, [fetchProducts]);

  const columns = [
    {
      title: 'ìƒí’ˆëª…',
      dataIndex: 'title',
      key: 'title',
      ellipsis: true,
    },
    // ... ë‹¤ë¥¸ ì»¬ëŸ¼ë“¤
  ];

  return (
    <div>
      <Card title="ìƒí’ˆ ëª©ë¡" extra={<Button type="primary">ì¶”ê°€</Button>}>
        <Table
          columns={columns}
          dataSource={products}
          loading={loading}
          rowKey="id"
          rowSelection={{
            selectedRowKeys,
            onChange: setSelectedRowKeys,
          }}
        />
      </Card>

      <Modal
        title="ì‚­ì œ í™•ì¸"
        open={deleteModalVisible}
        onCancel={() => setDeleteModalVisible(false)}
        footer={[
          <Button key="cancel" onClick={() => setDeleteModalVisible(false)}>
            ì·¨ì†Œ
          </Button>,
          <Button key="delete" type="primary" danger onClick={handleDelete}>
            ì‚­ì œ
          </Button>,
        ]}
      >
        ì„ íƒëœ ìƒí’ˆì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?
      </Modal>
    </div>
  );
};

export default ProductList;
```

### 2. ìƒíƒœ ê´€ë¦¬ (Zustand)
```typescript
// âœ… ì¢‹ì€ ì˜ˆì‹œ
interface ProductsState {
  products: Product[];
  loading: boolean;
  error: string | null;
  filters: ProductFilters;

  fetchProducts: (filters?: ProductFilters) => Promise<void>;
  createProduct: (product: ProductCreateRequest) => Promise<void>;
  updateProduct: (id: string, product: ProductUpdateRequest) => Promise<void>;
  deleteProduct: (id: string) => Promise<void>;
  setFilters: (filters: Partial<ProductFilters>) => void;
  clearError: () => void;
}

export const useProductsStore = create<ProductsState>()(
  devtools(
    (set, get) => ({
      products: [],
      loading: false,
      error: null,
      filters: {},

      fetchProducts: async (filters = {}) => {
        set({ loading: true, error: null });

        try {
          const response = await apiClient.getProducts(filters);
          set({
            products: response.items,
            loading: false
          });
        } catch (error) {
          set({
            error: 'ìƒí’ˆ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
            loading: false
          });
        }
      },

      // ... ë‹¤ë¥¸ ì•¡ì…˜ë“¤
    }),
    { name: 'products-store' }
  )
);
```

### 3. API í´ë¼ì´ì–¸íŠ¸
```typescript
// âœ… ì¢‹ì€ ì˜ˆì‹œ
import axios, { AxiosResponse } from 'axios';

class ApiClient {
  private client = axios.create({
    baseURL: '/api/v1',
    timeout: 30000,
  });

  constructor() {
    // ì‘ë‹µ ì¸í„°ì…‰í„°
    this.client.interceptors.response.use(
      (response: AxiosResponse) => response,
      (error) => {
        if (error.response?.status === 401) {
          // ì¸ì¦ ë§Œë£Œ ì²˜ë¦¬
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }

  async getProducts(params?: ProductFilters): Promise<ProductListResponse> {
    const response = await this.client.get('/products', { params });
    return response.data;
  }

  async createProduct(product: ProductCreateRequest): Promise<Product> {
    const response = await this.client.post('/products', product);
    return response.data;
  }
}

// âŒ ë‚˜ìœ ì˜ˆì‹œ
class BadApiClient {
  async getData() {
    // ì§ì ‘ fetch ì‚¬ìš©, ì—ëŸ¬ ì²˜ë¦¬ ì—†ìŒ
    const response = await fetch('/api/data');
    return response.json();
  }
}
```

### 4. íƒ€ì… ì •ì˜
```typescript
// âœ… ì¢‹ì€ ì˜ˆì‹œ
// types/index.ts
export interface Product {
  id: string;
  title: string;
  price: number;
  category: string;
  created_at: string;
  updated_at: string;
}

export interface ProductFilters {
  category?: string;
  min_price?: number;
  max_price?: number;
  search?: string;
  limit?: number;
  offset?: number;
}

export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  timestamp: string;
}

// âŒ ë‚˜ìœ ì˜ˆì‹œ
interface Product {
  id: string;
  title: string;
  price: number;
  // íƒ€ì… ì •ì˜ ë¶ˆì™„ì „
}

type Filters = {
  category?: string;
  // ì„ íƒì  í•„ë“œë“¤ì´ any íƒ€ì…
}
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì‘ì„± ê°€ì´ë“œ

### 1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```python
# tests/unit/test_product_service.py
import pytest
from unittest.mock import Mock, AsyncMock

class TestProductService:
    @pytest.fixture
    def mock_repository(self):
        return Mock()

    @pytest.fixture
    def product_service(self, mock_repository):
        return ProductService(repository=mock_repository)

    async def test_get_product_success(self, product_service, mock_repository):
        """ìƒí’ˆ ì¡°íšŒ ì„±ê³µ í…ŒìŠ¤íŠ¸"""
        # Given
        mock_repository.get_by_id = AsyncMock(return_value=Product(id="1", title="Test"))

        # When
        result = await product_service.get_product("1")

        # Then
        assert result.is_success()
        assert result.get_value().title == "Test"
        mock_repository.get_by_id.assert_called_once_with("1")
```

### 2. í†µí•© í…ŒìŠ¤íŠ¸
```python
# tests/integration/test_api_endpoints.py
import pytest
from fastapi.testclient import TestClient

class TestProductAPI:
    def test_create_product(self, client: TestClient):
        """ìƒí’ˆ ìƒì„± API í…ŒìŠ¤íŠ¸"""
        # Given
        product_data = {
            "title": "í…ŒìŠ¤íŠ¸ ìƒí’ˆ",
            "price": 10000,
            "category": "electronics"
        }

        # When
        response = client.post("/api/v1/products", json=product_data)

        # Then
        assert response.status_code == 201
        data = response.json()
        assert data["title"] == "í…ŒìŠ¤íŠ¸ ìƒí’ˆ"
        assert "id" in data
```

## ğŸ“ ì»¤ë°‹ ë©”ì‹œì§€ ê°€ì´ë“œ

### ì»¤ë°‹ ë©”ì‹œì§€ í˜•ì‹
```bash
type(scope): description

[optional body]

[optional footer]
```

### Type ì¢…ë¥˜
- **feat**: ìƒˆë¡œìš´ ê¸°ëŠ¥
- **fix**: ë²„ê·¸ ìˆ˜ì •
- **docs**: ë¬¸ì„œ ë³€ê²½
- **style**: ì½”ë“œ ìŠ¤íƒ€ì¼ ë³€ê²½ (í¬ë§·íŒ… ë“±)
- **refactor**: ë¦¬íŒ©í† ë§
- **test**: í…ŒìŠ¤íŠ¸ ì½”ë“œ
- **chore**: ë¹Œë“œ, ì„¤ì • ë³€ê²½

### ì˜ˆì‹œ
```bash
feat(api): Add product synchronization endpoint

- Implement OwnerClan API integration for product sync
- Add pagination support for large datasets
- Include error handling and retry logic

Closes #123
```

## ğŸ”§ ì½”ë“œ í’ˆì§ˆ ë„êµ¬

### ESLint (TypeScript)
```bash
cd frontend
npm run lint        # ë¦°íŒ… ì‹¤í–‰
npm run lint:fix   # ìë™ ìˆ˜ì •
```

### Prettier (ì½”ë“œ í¬ë§·íŒ…)
```bash
cd frontend
npm run format      # ì½”ë“œ í¬ë§·íŒ…
```

### Black (Python í¬ë§·íŒ…)
```bash
black src/          # Python ì½”ë“œ í¬ë§·íŒ…
black --check src/  # í¬ë§·íŒ… í™•ì¸
```

### MyPy (Python íƒ€ì… ì²´í¬)
```bash
mypy src/           # íƒ€ì… ì²´í¬
```

## ğŸš€ ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œ

### 1. ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ - ì¸ë±ìŠ¤ í™œìš©
async def find_active_products_by_supplier(self, supplier_id: str) -> List[Product]:
    stmt = select(Product).where(
        and_(
            Product.supplier_id == supplier_id,
            Product.is_active == True
        )
    ).options(selectinload(Product.category))

    return await self.db.execute(stmt)

# âŒ ë‚˜ìœ ì˜ˆì‹œ - N+1 ì¿¼ë¦¬
async def bad_find_products(self, supplier_id: str) -> List[Product]:
    products = await self.get_products_by_supplier(supplier_id)
    for product in products:
        # ê° ìƒí’ˆë§ˆë‹¤ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ (N+1 ë¬¸ì œ)
        category = await self.get_category(product.category_id)
```

### 2. ìºì‹± ì „ëµ
```python
from functools import lru_cache

@lru_cache(maxsize=1000)
async def get_cached_product(product_id: str) -> Optional[Product]:
    """ìƒí’ˆ ì •ë³´ ìºì‹±"""
    return await repository.get_product_by_id(product_id)
```

### 3. ë¹„ë™ê¸° ì²˜ë¦¬ ìµœì í™”
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ - ë³‘ë ¬ ì²˜ë¦¬
async def process_multiple_suppliers(self, supplier_ids: List[str]) -> Dict[str, List[Product]]:
    """ì—¬ëŸ¬ ê³µê¸‰ì‚¬ì˜ ìƒí’ˆì„ ë³‘ë ¬ë¡œ ì²˜ë¦¬"""
    semaphore = asyncio.Semaphore(5)  # ë™ì‹œì„± ì œì–´

    async def process_supplier(supplier_id: str) -> Tuple[str, List[Product]]:
        async with semaphore:
            products = await self.sync_supplier_products(supplier_id)
            return supplier_id, products

    # ëª¨ë“  ê³µê¸‰ì‚¬ë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬
    tasks = [process_supplier(sid) for sid in supplier_ids]
    results = await asyncio.gather(*tasks)

    return dict(results)

# âŒ ë‚˜ìœ ì˜ˆì‹œ - ìˆœì°¨ ì²˜ë¦¬
async def bad_process_suppliers(self, supplier_ids: List[str]):
    results = {}
    for supplier_id in supplier_ids:
        # ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬ (ëŠë¦¼)
        products = await self.sync_supplier_products(supplier_id)
        results[supplier_id] = products
```

ì´ ê°€ì´ë“œë¼ì¸ì„ ë”°ë¼ ì¼ê´€ëœ ì½”ë“œ ìŠ¤íƒ€ì¼ê³¼ í’ˆì§ˆì„ ìœ ì§€í•˜ì„¸ìš”.