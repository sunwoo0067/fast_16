---
alwaysApply: false
description: "ë“œëì‹­í•‘ ìë™í™” ì‹œìŠ¤í…œì˜ ë°ì´í„°ë² ì´ìŠ¤ ì‚¬ìš© ê°€ì´ë“œë¼ì¸"
globs: "src/adapters/persistence/**/*.py,src/services/**/*.py"
---

# ë°ì´í„°ë² ì´ìŠ¤ ì‚¬ìš© ê°€ì´ë“œë¼ì¸

ë“œëì‹­í•‘ ìë™í™” ì‹œìŠ¤í…œì€ **SQLAlchemy ORM**ê³¼ **Alembic ë§ˆì´ê·¸ë ˆì´ì…˜**ì„ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡°

### í…Œì´ë¸” ì„¤ê³„ ì›ì¹™
```python
# src/adapters/persistence/models.py
class Product(Base):
    """í—¥ì‚¬ê³ ë‚  ì•„í‚¤í…ì²˜ì˜ ìƒí’ˆ í…Œì´ë¸”"""
    __tablename__ = "products"

    # ê¸°ë³¸ í‚¤ (UUID ê¸°ë°˜)
    id = Column(String, primary_key=True, index=True)

    # ì™¸ë˜ í‚¤ ê´€ê³„
    supplier_id = Column(String, index=True, nullable=False)

    # ë¹„ì¦ˆë‹ˆìŠ¤ ë°ì´í„°
    title = Column(String, nullable=False)
    price_data = Column(Text, nullable=False)  # JSON í˜•íƒœ ê°€ê²© ì •ë³´
    options = Column(Text)  # JSON í˜•íƒœ ì˜µì…˜ ì •ë³´
    images = Column(Text)   # JSON í˜•íƒœ ì´ë¯¸ì§€ ì •ë³´

    # ìƒíƒœ ë° ë™ê¸°í™” ì •ë³´
    is_active = Column(Boolean, default=True)
    sync_status = Column(String, default="pending")
    last_synced_at = Column(DateTime(timezone=True))

    # í•´ì‹œ ê¸°ë°˜ ì¤‘ë³µ ê²€ì¦
    hash_key = Column(String, index=True)

    # ê°ì‚¬ í•„ë“œ
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # ì„±ëŠ¥ ìµœì í™” ì¸ë±ìŠ¤
    __table_args__ = (
        Index('ix_products_supplier_active', 'supplier_id', 'is_active'),
        Index('ix_products_hash_key', 'hash_key'),
        Index('ix_products_last_synced', 'last_synced_at'),
    )
```

### ì¸ë±ìŠ¤ ì„¤ê³„ ì „ëµ
```python
# ë³µí•© ì¸ë±ìŠ¤ ì˜ˆì‹œ
__table_args__ = (
    Index('ix_products_supplier_category', 'supplier_id', 'category_id'),
    Index('ix_products_sync_status', 'sync_status', 'last_synced_at'),
    Index('ix_orders_supplier_status', 'supplier_id', 'status'),
)
```

## ğŸ” ì¿¼ë¦¬ ì‘ì„± ê°€ì´ë“œ

### ê¸°ë³¸ ì¿¼ë¦¬ íŒ¨í„´
```python
from sqlalchemy import select, and_, or_, desc
from sqlalchemy.ext.asyncio import AsyncSession

class ProductRepository:
    async def find_by_supplier(self, db: AsyncSession, supplier_id: str) -> List[Product]:
        """ê³µê¸‰ì‚¬ë³„ ìƒí’ˆ ì¡°íšŒ"""
        stmt = select(Product).where(
            Product.supplier_id == supplier_id,
            Product.is_active == True
        ).order_by(desc(Product.created_at))

        result = await db.execute(stmt)
        return result.scalars().all()

    async def find_by_price_range(self, db: AsyncSession, min_price: int, max_price: int) -> List[Product]:
        """ê°€ê²© ë²”ìœ„ë¡œ ìƒí’ˆ ì¡°íšŒ"""
        stmt = select(Product).where(
            and_(
                Product.price_data.contains(f'"original_price": {min_price}'),  # JSON í•„ë“œ ê²€ìƒ‰
                Product.is_active == True
            )
        )

        result = await db.execute(stmt)
        return result.scalars().all()
```

### JSON í•„ë“œ ì¿¼ë¦¬
```python
# JSON í•„ë“œì—ì„œ íŠ¹ì • ê°’ ì¶”ì¶œ
from sqlalchemy import text

async def find_products_by_margin_rate(self, db: AsyncSession, min_margin: float) -> List[Product]:
    """ë§ˆì§„ìœ¨ ë²”ìœ„ë¡œ ìƒí’ˆ ì¡°íšŒ"""
    stmt = select(Product).where(
        text("CAST(SUBSTRING(price_data, 'margin_rate.: ([0-9.]+)') AS FLOAT) >= :min_margin")
    ).params(min_margin=min_margin)

    result = await db.execute(stmt)
    return result.scalars().all()

# JSONB contains ì—°ì‚°ì ì‚¬ìš©
async def find_products_with_options(self, db: AsyncSession) -> List[Product]:
    """ì˜µì…˜ì´ ìˆëŠ” ìƒí’ˆ ì¡°íšŒ"""
    stmt = select(Product).where(
        Product.options.isnot(None)  # JSON í•„ë“œê°€ NULLì´ ì•„ë‹˜
    )

    result = await db.execute(stmt)
    return result.scalars().all()
```

### í˜ì´ì§€ë„¤ì´ì…˜
```python
async def find_products_paginated(
    self,
    db: AsyncSession,
    page: int = 1,
    page_size: int = 20,
    supplier_id: Optional[str] = None
) -> Tuple[List[Product], int]:
    """í˜ì´ì§•ì„ ì‚¬ìš©í•œ ìƒí’ˆ ì¡°íšŒ"""
    # ê¸°ë³¸ ì¿¼ë¦¬
    stmt = select(Product).where(Product.is_active == True)

    if supplier_id:
        stmt = stmt.where(Product.supplier_id == supplier_id)

    # ì „ì²´ ê°œìˆ˜ ì¡°íšŒ
    count_stmt = select(func.count()).select_from(stmt.subquery())
    total_result = await db.execute(count_stmt)
    total = total_result.scalar()

    # í˜ì´ì§• ì ìš©
    offset = (page - 1) * page_size
    stmt = stmt.order_by(desc(Product.created_at)).offset(offset).limit(page_size)

    result = await db.execute(stmt)
    products = result.scalars().all()

    return products, total
```

## ğŸ’¾ ë°ì´í„° ì €ì¥ ë° ì—…ë°ì´íŠ¸

### ë²Œí¬ ì‘ì—…
```python
async def bulk_save_products(self, db: AsyncSession, products: List[Product]) -> None:
    """ìƒí’ˆ ëŒ€ëŸ‰ ì €ì¥"""
    for product in products:
        # ì¤‘ë³µ ì²´í¬
        existing = await db.get(Product, product.id)
        if existing:
            # ì—…ë°ì´íŠ¸
            for key, value in product.__dict__.items():
                if not key.startswith('_'):
                    setattr(existing, key, value)
        else:
            # ìƒì„±
            db.add(Product(**product.__dict__))

    await db.commit()

async def bulk_update_sync_status(
    self,
    db: AsyncSession,
    product_ids: List[str],
    status: str
) -> None:
    """ì—¬ëŸ¬ ìƒí’ˆì˜ ë™ê¸°í™” ìƒíƒœ ì—…ë°ì´íŠ¸"""
    from sqlalchemy import update

    stmt = update(Product).where(
        Product.id.in_(product_ids)
    ).values(
        sync_status=status,
        last_synced_at=datetime.now()
    )

    await db.execute(stmt)
    await db.commit()
```

### íŠ¸ëœì­ì…˜ ê´€ë¦¬
```python
async def sync_products_with_transaction(
    self,
    db: AsyncSession,
    products: List[Product]
) -> Result[bool, str]:
    """íŠ¸ëœì­ì…˜ì„ ì‚¬ìš©í•œ ìƒí’ˆ ë™ê¸°í™”"""
    try:
        # íŠ¸ëœì­ì…˜ ì‹œì‘
        for product in products:
            # ìƒí’ˆ ì €ì¥
            await self.save_product(db, product)

            # ë™ê¸°í™” ì´ë ¥ ì €ì¥
            await self.save_sync_history(db, product.id, "success")

        await db.commit()
        return Success(True)

    except Exception as e:
        await db.rollback()
        return Failure(f"ë™ê¸°í™” ì‹¤íŒ¨: {str(e)}")
```

## ğŸ”„ ë§ˆì´ê·¸ë ˆì´ì…˜ ê´€ë¦¬

### ë§ˆì´ê·¸ë ˆì´ì…˜ íŒŒì¼ êµ¬ì¡°
```python
# alembic/versions/xxx_description.py
"""ë§ˆì´ê·¸ë ˆì´ì…˜ ì„¤ëª…

Revision ID: xxx
Revises: ì´ì „_ë¦¬ë¹„ì „_ID
Create Date: 2025-01-01 00:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = 'xxx'
down_revision = 'ì´ì „_ë¦¬ë¹„ì „_ID'
branch_labels = None
depends_on = None

def upgrade() -> None:
    """í…Œì´ë¸” ìƒì„± ë˜ëŠ” ìˆ˜ì •"""
    op.create_table('new_table',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )

def downgrade() -> None:
    """ë¡¤ë°± ì‹œ ì‹¤í–‰"""
    op.drop_table('new_table')
```

### ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
```bash
# ìƒˆë¡œìš´ ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„±
alembic revision --autogenerate -m "ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€"

# ë§ˆì´ê·¸ë ˆì´ì…˜ ì ìš©
alembic upgrade head

# íŠ¹ì • ë¦¬ë¹„ì „ìœ¼ë¡œ ë¡¤ë°±
alembic downgrade -1

# í˜„ì¬ ìƒíƒœ í™•ì¸
alembic current
alembic history
```

## ğŸ—ï¸ ëª¨ë¸ ì„¤ê³„ ì›ì¹™

### ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„ (DDD)
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ - ë„ë©”ì¸ ë¡œì§ í¬í•¨
class Product(Base):
    """ìƒí’ˆ ë„ë©”ì¸ ëª¨ë¸"""

    def is_available(self) -> bool:
        """ìƒí’ˆ êµ¬ë§¤ ê°€ëŠ¥ ì—¬ë¶€"""
        return (
            self.is_active and
            self.stock_quantity > 0 and
            self.sync_status == "synced"
        )

    def get_display_price(self) -> int:
        """í‘œì‹œ ê°€ê²© ê³„ì‚°"""
        return self.price_data.get("final_price", 0)

    def update_stock(self, quantity: int) -> None:
        """ì¬ê³  ì—…ë°ì´íŠ¸"""
        self.stock_quantity = max(0, self.stock_quantity + quantity)
        self.updated_at = datetime.now()

# âŒ ë‚˜ìœ ì˜ˆì‹œ - ìˆœìˆ˜ ë°ì´í„° ëª¨ë¸
class BadProduct(Base):
    """ë‹¨ìˆœ ë°ì´í„° ëª¨ë¸"""
    # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì—†ìŒ
    pass
```

### JSON í•„ë“œ ì‚¬ìš©
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ - JSON í•„ë“œë¡œ ìœ ì—°ì„± í™•ë³´
class Product(Base):
    price_data = Column(Text)  # JSON: {"original": 10000, "sale": 8000, "margin": 0.3}
    options = Column(Text)      # JSON: [{"name": "ìƒ‰ìƒ", "value": "ë¹¨ê°•", "price": 1000}]
    images = Column(Text)       # JSON: ["image1.jpg", "image2.jpg"]

# âŒ ë‚˜ìœ ì˜ˆì‹œ - ê³¼ë„í•œ ì •ê·œí™”
class BadProduct(Base):
    price_original = Column(Integer)
    price_sale = Column(Integer)
    price_margin = Column(Float)
    # ì˜µì…˜ë³„ ê°œë³„ í…Œì´ë¸” (ê´€ê³„ ë³µì¡ë„ ì¦ê°€)
```

## ğŸ” ì„±ëŠ¥ ìµœì í™”

### ì¿¼ë¦¬ ìµœì í™”
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ - í•„ìš”í•œ í•„ë“œë§Œ ì„ íƒ
async def get_product_titles(self, db: AsyncSession, supplier_id: str) -> List[str]:
    stmt = select(Product.title).where(
        Product.supplier_id == supplier_id,
        Product.is_active == True
    )
    result = await db.execute(stmt)
    return [row[0] for row in result]

# âŒ ë‚˜ìœ ì˜ˆì‹œ - ë¶ˆí•„ìš”í•œ ë°ì´í„° ë¡œë“œ
async def bad_get_products(self, db: AsyncSession, supplier_id: str):
    stmt = select(Product)  # ëª¨ë“  í•„ë“œ ë¡œë“œ
    result = await db.execute(stmt)
    products = result.scalars().all()

    # ì‹¤ì œë¡œëŠ” titleë§Œ í•„ìš”í•œë° ëª¨ë“  í•„ë“œ ë¡œë“œ
    return [p.title for p in products]
```

### ì§€ì—° ë¡œë”© ê´€ë¦¬
```python
from sqlalchemy.orm import selectinload

# âœ… ì¢‹ì€ ì˜ˆì‹œ - í•„ìš”í•œ ê´€ê³„ë§Œ ë¡œë“œ
async def get_products_with_category(self, db: AsyncSession) -> List[Product]:
    stmt = select(Product).options(
        selectinload(Product.category)  # ì¹´í…Œê³ ë¦¬ë§Œ ë¯¸ë¦¬ ë¡œë“œ
    ).where(Product.is_active == True)

    result = await db.execute(stmt)
    return result.scalars().all()

# âŒ ë‚˜ìœ ì˜ˆì‹œ - ë¶ˆí•„ìš”í•œ ê´€ê³„ ë¡œë“œ
async def bad_get_products(self, db: AsyncSession):
    stmt = select(Product).options(
        selectinload(Product.category),
        selectinload(Product.supplier),
        selectinload(Product.sync_history)  # ë¶ˆí•„ìš”í•œ ê´€ê³„ë“¤
    )
```

### ë°°ì¹˜ ì²˜ë¦¬
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ - ë°°ì¹˜ ì²˜ë¦¬
async def bulk_update_products(self, db: AsyncSession, updates: List[Dict]) -> None:
    """ìƒí’ˆ ì •ë³´ ëŒ€ëŸ‰ ì—…ë°ì´íŠ¸"""
    batch_size = 100

    for i in range(0, len(updates), batch_size):
        batch = updates[i:i + batch_size]

        # ë°°ì¹˜ ë‹¨ìœ„ë¡œ ì—…ë°ì´íŠ¸
        for update_data in batch:
            stmt = update(Product).where(
                Product.id == update_data['id']
            ).values(**update_data)

            await db.execute(stmt)

        await db.commit()  # ë°°ì¹˜ë§ˆë‹¤ ì»¤ë°‹

# âŒ ë‚˜ìœ ì˜ˆì‹œ - ê°œë³„ ì²˜ë¦¬
async def bad_bulk_update(self, db: AsyncSession, updates: List[Dict]):
    for update_data in updates:
        stmt = update(Product).where(Product.id == update_data['id']).values(**update_data)
        await db.execute(stmt)
        await db.commit()  # ë§¤ë²ˆ ì»¤ë°‹ (ì„±ëŠ¥ ì €í•˜)
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ë°ì´í„°ë² ì´ìŠ¤

### í…ŒìŠ¤íŠ¸ìš© ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
```python
# tests/conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from src.adapters.persistence.models import Base

@pytest.fixture(scope="session")
def test_engine():
    """í…ŒìŠ¤íŠ¸ìš© ë°ì´í„°ë² ì´ìŠ¤ ì—”ì§„"""
    engine = create_engine(
        "sqlite:///./test_dropshipping.db",
        echo=False  # í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ë¡œê·¸ ì¶œë ¥ ì•ˆ í•¨
    )

    # í…Œì´ë¸” ìƒì„±
    Base.metadata.create_all(bind=engine)

    yield engine

    # í…ŒìŠ¤íŠ¸ ì™„ë£Œ í›„ ì •ë¦¬
    Base.metadata.drop_all(bind=engine)

@pytest.fixture
def test_db(test_engine):
    """í…ŒìŠ¤íŠ¸ìš© ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜"""
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)

    with SessionLocal() as session:
        try:
            yield session
        finally:
            session.close()
```

### í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
```python
# tests/fixtures/product_fixtures.py
@pytest.fixture
def sample_products(test_db):
    """í…ŒìŠ¤íŠ¸ìš© ìƒí’ˆ ë°ì´í„°"""
    products = [
        Product(
            id="product_001",
            title="í…ŒìŠ¤íŠ¸ ìƒí’ˆ 1",
            supplier_id="supplier_001",
            price_data='{"original_price": 10000, "margin_rate": 0.3}',
            is_active=True
        ),
        Product(
            id="product_002",
            title="í…ŒìŠ¤íŠ¸ ìƒí’ˆ 2",
            supplier_id="supplier_001",
            price_data='{"original_price": 20000, "margin_rate": 0.2}',
            is_active=True
        )
    ]

    for product in products:
        test_db.add(product)

    test_db.commit()

    return products
```

## ğŸ”’ ë°ì´í„° ë¬´ê²°ì„±

### ì œì•½ì¡°ê±´ ì„¤ì •
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ - ì ì ˆí•œ ì œì•½ì¡°ê±´
class Product(Base):
    __tablename__ = "products"

    id = Column(String, primary_key=True, index=True)
    supplier_id = Column(String, nullable=False, index=True)
    title = Column(String, nullable=False)
    price_data = Column(Text, nullable=False)

    # ì²´í¬ ì œì•½ì¡°ê±´
    __table_args__ = (
        CheckConstraint('length(title) > 0', name='title_not_empty'),
        CheckConstraint('supplier_id != ""', name='supplier_id_not_empty'),
    )

# âŒ ë‚˜ìœ ì˜ˆì‹œ - ì œì•½ì¡°ê±´ ë¶€ì¡±
class BadProduct(Base):
    title = Column(String)  # NULL ê°€ëŠ¥
    supplier_id = Column(String)  # NULL ê°€ëŠ¥
    # ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥ ì—†ìŒ
```

### ë°ì´í„° ê²€ì¦
```python
# âœ… ì¢‹ì€ ì˜ˆì‹œ - ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
async def save_product(self, db: AsyncSession, product: Product) -> Result[Product, str]:
    """ìƒí’ˆ ì €ì¥ (ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦ í¬í•¨)"""
    # 1. ê¸°ë³¸ ë°ì´í„° ê²€ì¦
    if not product.title or len(product.title.strip()) == 0:
        return Failure("ìƒí’ˆëª…ì´ í•„ìš”í•©ë‹ˆë‹¤")

    if not product.supplier_id:
        return Failure("ê³µê¸‰ì‚¬ IDê°€ í•„ìš”í•©ë‹ˆë‹¤")

    # 2. ë¹„ì¦ˆë‹ˆìŠ¤ ê·œì¹™ ê²€ì¦
    if product.price_data.get("original_price", 0) <= 0:
        return Failure("ìœ íš¨í•œ ê°€ê²©ì´ í•„ìš”í•©ë‹ˆë‹¤")

    if product.margin_rate < 0.1:
        return Failure("ë§ˆì§„ìœ¨ì´ ë„ˆë¬´ ë‚®ìŠµë‹ˆë‹¤ (ìµœì†Œ 10%)")

    # 3. ì¤‘ë³µ ì²´í¬
    existing = await self.find_by_hash(product.hash_key)
    if existing:
        return Failure("ë™ì¼í•œ ìƒí’ˆì´ ì´ë¯¸ ì¡´ì¬í•©ë‹ˆë‹¤")

    # 4. ì €ì¥
    db.add(product)
    await db.commit()

    return Success(product)

# âŒ ë‚˜ìœ ì˜ˆì‹œ - ê²€ì¦ ë¶€ì¡±
async def bad_save_product(self, db: AsyncSession, product: Product):
    db.add(product)
    await db.commit()
    return product  # ê²€ì¦ ì—†ì´ ì €ì¥
```

## ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…

### ì¿¼ë¦¬ ì„±ëŠ¥ ë¡œê¹…
```python
import time
from src.shared.logging import get_logger

logger = get_logger(__name__)

async def monitored_query(db: AsyncSession, query_name: str):
    """ì¿¼ë¦¬ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§"""
    start_time = time.time()

    try:
        result = await db.execute(stmt)
        duration = time.time() - start_time

        logger.info(
            f"ì¿¼ë¦¬ ì‹¤í–‰ ì™„ë£Œ: {query_name}",
            extra={
                "query_name": query_name,
                "duration_ms": duration * 1000,
                "row_count": len(result.all()) if hasattr(result, 'all') else 0
            }
        )

        return result

    except Exception as e:
        duration = time.time() - start_time
        logger.error(
            f"ì¿¼ë¦¬ ì‹¤í–‰ ì‹¤íŒ¨: {query_name}",
            extra={
                "query_name": query_name,
                "duration_ms": duration * 1000,
                "error": str(e)
            }
        )
        raise
```

### ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ëª¨ë‹ˆí„°ë§
```python
async def check_database_health(db: AsyncSession) -> Dict[str, Any]:
    """ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ í™•ì¸"""
    health_info = {
        "connected": False,
        "tables_count": 0,
        "total_records": 0,
        "errors": []
    }

    try:
        # ì—°ê²° í…ŒìŠ¤íŠ¸
        await db.execute(text("SELECT 1"))
        health_info["connected"] = True

        # í…Œì´ë¸” ê°œìˆ˜ í™•ì¸
        result = await db.execute(text(
            "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public'"
        ))
        health_info["tables_count"] = result.scalar()

        # ì „ì²´ ë ˆì½”ë“œ ìˆ˜ (ëŒ€ëµì )
        for table_name in ["products", "orders", "suppliers"]:
            try:
                result = await db.execute(text(f"SELECT COUNT(*) FROM {table_name}"))
                count = result.scalar()
                health_info["total_records"] += count
            except:
                pass

    except Exception as e:
        health_info["errors"].append(str(e))

    return health_info
```

## ğŸ”§ ìš´ì˜ ê°€ì´ë“œ

### ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…
```bash
# SQLite ë°±ì—…
cp dropshipping.db dropshipping_backup_$(date +%Y%m%d_%H%M%S).db

# PostgreSQL ë°±ì—…
pg_dump -h localhost -U username dropshipping > backup_$(date +%Y%m%d_%H%M%S).sql
```

### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
```sql
-- ëŠë¦° ì¿¼ë¦¬ í™•ì¸
SELECT query, calls, total_time, mean_time
FROM pg_stat_statements
WHERE mean_time > 100  -- 100ms ì´ìƒ ì¿¼ë¦¬
ORDER BY mean_time DESC;

-- í…Œì´ë¸” í¬ê¸° í™•ì¸
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### ì¸ë±ìŠ¤ ìµœì í™”
```sql
-- ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì¸ë±ìŠ¤ í™•ì¸
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan as scans
FROM pg_stat_user_indexes
WHERE idx_scan = 0  -- ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì¸ë±ìŠ¤
ORDER BY tablename, indexname;

-- ì¸ë±ìŠ¤ ì‚¬ìš©ë¥  í™•ì¸
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;
```

ì´ ê°€ì´ë“œë¼ì¸ì„ ë”°ë¼ íš¨ìœ¨ì ì´ê³  ì•ˆì „í•œ ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—…ì„ ìˆ˜í–‰í•˜ì„¸ìš”.