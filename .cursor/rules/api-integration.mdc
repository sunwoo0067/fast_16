---
alwaysApply: false
description: "ë“œëì‹­í•‘ ìë™í™” ì‹œìŠ¤í…œì˜ API ì—°ë™ ê°€ì´ë“œë¼ì¸"
globs: "src/adapters/**/*.py,src/services/**/*.py"
---

# API ì—°ë™ ê°€ì´ë“œë¼ì¸

ë“œëì‹­í•‘ ìë™í™” ì‹œìŠ¤í…œì€ **OwnerClan API**ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, ë‹¤ì–‘í•œ ì™¸ë¶€ ì„œë¹„ìŠ¤ì™€ ì—°ë™í•©ë‹ˆë‹¤.

## ğŸ”— OwnerClan API ì—°ë™

### ì¸ì¦ ë°©ì‹
```python
# src/adapters/suppliers/ownerclan_adapter.py
from src.core.ports.supplier_port import SupplierCredentials

async def authenticate(self, credentials: SupplierCredentials) -> str:
    """JWT í† í° ë°œê¸‰"""
    auth_data = {
        "service": "ownerclan",
        "userType": "seller",  # íŒë§¤ì‚¬ ê³„ì •
        "username": credentials.username,
        "password": credentials.password
    }

    response = await self.client.post(self.auth_url, json=auth_data)
    token = response.text.strip()

    if not token.startswith('eyJ'):
        raise ValueError("Invalid JWT token")

    return token
```

### GraphQL ì¿¼ë¦¬ êµ¬ì¡°
```python
# í‘œì¤€ GraphQL ì¿¼ë¦¬ íŒ¨í„´
query = """
query GetAllItems($first: Int!, $after: String, $dateFrom: Int) {
    allItems(first: $first, after: $after, dateFrom: $dateFrom) {
        pageInfo {
            hasNextPage
            endCursor
        }
        edges {
            node {
                key
                name
                price
                status
                # í•„ìš”í•œ í•„ë“œë“¤...
            }
        }
    }
}
"""

variables = {
    "first": 100,
    "dateFrom": cutoff_timestamp
}
```

## ğŸ“Š ì£¼ìš” API ì—”ë“œí¬ì¸íŠ¸

### ìƒí’ˆ ë™ê¸°í™” API
```python
# ìƒí’ˆ ì „ì²´ ì¡°íšŒ (í˜ì´ì§•)
async def fetch_all_items(supplier_id, account_id, first=100, after=None, date_from=None)

# ìƒí’ˆ ë³€ê²½ ì´ë ¥ ì¡°íšŒ
async def fetch_item_histories(supplier_id, account_id, first=100, date_from=None, kind=None)

# íŠ¹ì • ì¡°ê±´ ìƒí’ˆ ì¡°íšŒ
async def fetch_items_by_price_range(supplier_id, account_id, min_price, max_price)
async def fetch_items_by_category(supplier_id, account_id, category_key)
async def fetch_items_by_vendor(supplier_id, account_id, vendor_code)
```

### ì£¼ë¬¸ ê´€ë¦¬ API
```python
# ì£¼ë¬¸ ìƒì„±
async def create_order(supplier_id, account_id, order_data)

# ì£¼ë¬¸ ì¡°íšŒ
async def fetch_orders(supplier_id, account_id, first=50, shipped_after=None, status=None)

# ì£¼ë¬¸ ì·¨ì†Œ
async def cancel_order(supplier_id, account_id, order_key)
```

### ë°˜í’ˆ/êµí™˜ API
```python
# ë°˜í’ˆ/êµí™˜ ìš”ì²­
async def request_refund_or_exchange(supplier_id, account_id, order_key, refund_data)
```

### ë¬¸ì˜ ê´€ë¦¬ API
```python
# 1:1 ë¬¸ì˜ ì¡°íšŒ
async def fetch_qna_articles(supplier_id, account_id, first=10, date_from=None)

# ê¸´ê¸‰ ë©”ì‹œì§€ ì¡°íšŒ
async def fetch_emergency_messages(supplier_id, account_id, first=5, status=None)
```

## ğŸ”„ ë™ê¸°í™” ì „ëµ

### í˜ì´ì§• ì²˜ë¦¬
```python
async def sync_all_items(supplier_id: str, account_id: str):
    """í˜ì´ì§•ì„ ì‚¬ìš©í•œ ì „ì²´ ìƒí’ˆ ë™ê¸°í™”"""
    all_items = []
    after_cursor = None

    while True:
        items, next_cursor = await adapter.fetch_all_items(
            supplier_id=supplier_id,
            account_id=account_id,
            first=100,
            after=after_cursor
        )

        all_items.extend(items)

        if not next_cursor:
            break
        after_cursor = next_cursor

    return all_items
```

### ì¦ë¶„ ë™ê¸°í™”
```python
async def sync_recent_changes(supplier_id: str, account_id: str, last_sync_time: int):
    """ìµœê·¼ ë³€ê²½ì‚¬í•­ë§Œ ë™ê¸°í™”"""
    # ë³€ê²½ ì´ë ¥ ì¡°íšŒ
    histories = await adapter.fetch_item_histories(
        supplier_id=supplier_id,
        account_id=account_id,
        date_from=last_sync_time,
        kind="soldout"  # í’ˆì ˆ ì´ë ¥ ìš°ì„ 
    )

    # ë³€ê²½ëœ ìƒí’ˆë“¤ë§Œ ìƒì„¸ ì¡°íšŒ
    changed_item_keys = list(set([h.item_key for h in histories]))

    for item_key in changed_item_keys:
        item = await adapter.fetch_item(item_key)
        await repository.save_item(item)
```

### í¬ë¡  ìŠ¤ì¼€ì¤„ë§
```python
# scripts/scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler

async def schedule_sync_jobs():
    """ë™ê¸°í™” ì‘ì—… ìŠ¤ì¼€ì¤„ë§"""
    scheduler = AsyncIOScheduler()

    # ìƒí’ˆ ë™ê¸°í™” (10ë¶„ë§ˆë‹¤)
    scheduler.add_job(
        sync_all_products,
        'interval',
        minutes=10,
        id='product_sync'
    )

    # ì£¼ë¬¸ ë™ê¸°í™” (5ë¶„ë§ˆë‹¤)
    scheduler.add_job(
        sync_recent_orders,
        'interval',
        minutes=5,
        id='order_sync'
    )

    # ë¬¸ì˜ ëª¨ë‹ˆí„°ë§ (15ë¶„ë§ˆë‹¤)
    scheduler.add_job(
        monitor_inquiries,
        'interval',
        minutes=15,
        id='inquiry_monitor'
    )

    scheduler.start()
```

## ğŸš¨ ì—ëŸ¬ ì²˜ë¦¬ ë° ì¬ì‹œë„

### í‘œì¤€ ì—ëŸ¬ ì²˜ë¦¬
```python
from src.shared.result import Result, Success, Failure

async def safe_api_call(api_function, *args, **kwargs):
    """ì•ˆì „í•œ API í˜¸ì¶œ"""
    try:
        result = await api_function(*args, **kwargs)
        return Success(result)
    except httpx.TimeoutException:
        return Failure("API íƒ€ì„ì•„ì›ƒ")
    except httpx.HTTPStatusError as e:
        return Failure(f"HTTP {e.response.status_code}: {e.response.text}")
    except Exception as e:
        return Failure(f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {str(e)}")
```

### ì§€ìˆ˜ ë°±ì˜¤í”„ ì¬ì‹œë„
```python
import asyncio
import random

async def retry_with_backoff(
    func,
    max_retries: int = 3,
    base_delay: float = 1.0,
    max_delay: float = 60.0
):
    """ì§€ìˆ˜ ë°±ì˜¤í”„ë¥¼ ì‚¬ìš©í•œ ì¬ì‹œë„"""
    for attempt in range(max_retries):
        result = await func()

        if result.is_success():
            return result

        if attempt == max_retries - 1:
            return result  # ë§ˆì§€ë§‰ ì‹œë„

        # ì§€ìˆ˜ ë°±ì˜¤í”„: 1ì´ˆ, 2ì´ˆ, 4ì´ˆ, 8ì´ˆ...
        delay = min(base_delay * (2 ** attempt) + random.uniform(0, 1), max_delay)
        await asyncio.sleep(delay)

    return Failure("ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼")
```

## ğŸ“ API ì‘ë‹µ ë§¤í•‘

### OwnerClan ì‘ë‹µ â†’ ë„ë©”ì¸ ì—”í‹°í‹°
```python
def map_ownerclan_to_domain(ownerclan_item):
    """OwnerClan ìƒí’ˆì„ ë„ë©”ì¸ ì—”í‹°í‹°ë¡œ ë³€í™˜"""
    return Item(
        id=ownerclan_item.key,
        title=ownerclan_item.name,
        brand=ownerclan_item.origin,
        price=PricePolicy(
            original_price=ownerclan_item.price,
            margin_rate=0.3  # ê¸°ë³¸ ë§ˆì§„ìœ¨
        ),
        options=[
            ItemOption(
                name=opt.get("optionAttributes", [{}])[0].get("name", ""),
                value=opt.get("optionAttributes", [{}])[0].get("value", ""),
                price_adjustment=opt.get("price", 0),
                stock_quantity=opt.get("quantity", 0)
            )
            for opt in ownerclan_item.options
        ],
        images=[img.get("url") if isinstance(img, dict) else img
               for img in ownerclan_item.images],
        category_id=ownerclan_item.category.get("key") if ownerclan_item.category else "",
        supplier_id=supplier_id,
        is_active=ownerclan_item.status == "active"
    )
```

## ğŸ” ì¸ì¦ í† í° ê´€ë¦¬

### í† í° ì €ì¥ ë° ê°±ì‹ 
```python
# src/adapters/auth/token_store.py
class TokenStore:
    """í† í° ì €ì¥ ë° ìë™ ê°±ì‹ """

    async def get_valid_token(self, account: Account) -> Optional[str]:
        """ìœ íš¨í•œ í† í° ì¡°íšŒ (ë§Œë£Œ ì‹œ ìë™ ê°±ì‹ )"""
        if account.token_info and not account.token_info.is_expired():
            return account.token_info.access_token

        # í† í° ê°±ì‹ 
        new_token = await self.refresh_token(account)
        if new_token:
            await self.save_token(account, new_token)
            return new_token.access_token

        return None

    async def refresh_token(self, account: Account) -> Optional[TokenInfo]:
        """í† í° ê°±ì‹  (T-3ì¼ ì „ì— ìë™ ê°±ì‹ )"""
        # OwnerClan ì¸ì¦ ë¡œì§
        token = await ownerclan_adapter.authenticate(
            SupplierCredentials(
                supplier_id=account.supplier_id,
                account_id=account.account_name,
                username=account.username,
                password=account.password_encrypted
            )
        )

        return TokenInfo(access_token=token)
```

## ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…

### API í˜¸ì¶œ ë¡œê¹…
```python
from src.shared.logging import get_logger

logger = get_logger(__name__)

async def log_api_call(endpoint: str, method: str, status_code: int, duration: float):
    """API í˜¸ì¶œ ë¡œê¹…"""
    logger.info(
        f"API í˜¸ì¶œ: {method} {endpoint}",
        extra={
            "endpoint": endpoint,
            "method": method,
            "status_code": status_code,
            "duration_ms": duration * 1000,
            "timestamp": datetime.now().isoformat()
        }
    )
```

### ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
```python
async def monitor_api_performance():
    """API ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§"""
    metrics = {
        "total_requests": 0,
        "successful_requests": 0,
        "failed_requests": 0,
        "average_response_time": 0.0,
        "requests_per_minute": 0
    }

    # ì£¼ê¸°ì ìœ¼ë¡œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ë° ì €ì¥
    while True:
        await asyncio.sleep(60)  # 1ë¶„ë§ˆë‹¤
        # ë©”íŠ¸ë¦­ ê³„ì‚° ë° ì €ì¥
        pass
```

## ğŸ”§ í™˜ê²½ ì„¤ì •

### OwnerClan API ì„¤ì •
```bash
# .env íŒŒì¼
OWNERCLAN_USERNAME=your_ownerclan_id
OWNERCLAN_PASSWORD=your_ownerclan_password
OWNERCLAN_SUPPLIER_ID=your_supplier_id
OWNERCLAN_API_URL=https://api-sandbox.ownerclan.com/v1/graphql
OWNERCLAN_AUTH_URL=https://auth.ownerclan.com/auth
```

### Rate Limit ë° íƒ€ì„ì•„ì›ƒ
```python
# src/adapters/suppliers/ownerclan_adapter.py
def __init__(self, rate_limit_per_minute: int = 100, timeout: int = 30):
    self.rate_limit = rate_limit_per_minute
    self.timeout = timeout
    self.client = httpx.AsyncClient(timeout=timeout)
```

## ğŸ“ˆ ìµœì í™” ì „ëµ

### ë°°ì¹˜ ì²˜ë¦¬
```python
async def batch_process_items(items: List[Item], batch_size: int = 50):
    """ë°°ì¹˜ ì²˜ë¦¬ë¡œ ë©”ëª¨ë¦¬ ë° API íš¨ìœ¨ì„± í–¥ìƒ"""
    for i in range(0, len(items), batch_size):
        batch = items[i:i + batch_size]
        await process_batch(batch)
        await asyncio.sleep(0.1)  # API Rate Limit ì¤€ìˆ˜
```

### ìºì‹± ì „ëµ
```python
from functools import lru_cache

@lru_cache(maxsize=1000)
async def get_cached_item(item_key: str) -> Optional[Item]:
    """ìƒí’ˆ ì •ë³´ ìºì‹±"""
    return await repository.get_item_by_id(item_key)
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ê°€ì´ë“œë¼ì¸

### API ì–´ëŒ‘í„° í…ŒìŠ¤íŠ¸
```python
# tests/unit/test_ownerclan_adapter.py
async def test_fetch_all_items_pagination():
    """í˜ì´ì§• ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸"""
    items, next_cursor = await adapter.fetch_all_items(
        supplier_id="test",
        account_id="test",
        first=10
    )

    assert len(items) <= 10
    assert isinstance(next_cursor, str) or next_cursor is None
```

### í†µí•© í…ŒìŠ¤íŠ¸
```python
# tests/integration/test_api_integration.py
async def test_end_to_end_sync():
    """ì¢…ë‹¨ê°„ ë™ê¸°í™” í…ŒìŠ¤íŠ¸"""
    # 1. ìƒí’ˆ ìˆ˜ì§‘
    items = await sync_recent_products()

    # 2. ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ í™•ì¸
    for item in items:
        saved_item = await repository.get_item_by_id(item.id)
        assert saved_item is not None

    # 3. ë™ê¸°í™” ì´ë ¥ í™•ì¸
    sync_history = await repository.get_sync_history(sync_type="ingest")
    assert len(sync_history) > 0
```

## ğŸš€ ë°°í¬ ê³ ë ¤ì‚¬í•­

### í™˜ê²½ë³„ ì„¤ì •
```python
# settings.py
class Settings(BaseSettings):
    ownerclan_api_url: str = Field(
        default="https://api-sandbox.ownerclan.com/v1/graphql",
        env="OWNERCLAN_API_URL"
    )

    # Production í™˜ê²½ì—ì„œëŠ” ì‹¤ì œ API ì‚¬ìš©
    if os.getenv("ENVIRONMENT") == "production":
        ownerclan_api_url = "https://api.ownerclan.com/v1/graphql"
```

### ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼
```python
# src/services/monitoring_service.py
async def send_sync_notification(status: str, message: str):
    """ë™ê¸°í™” ìƒíƒœ ì•Œë¦¼"""
    if status == "success":
        await slack_bot.send_success_notification(message)
    elif status == "error":
        await slack_bot.send_error_notification(message)
        await email_service.send_alert(message)
```

ì´ ê°€ì´ë“œë¼ì¸ì„ ë”°ë¼ OwnerClan APIì™€ì˜ ì•ˆì •ì ì´ê³  íš¨ìœ¨ì ì¸ ì—°ë™ì„ êµ¬í˜„í•˜ì„¸ìš”.